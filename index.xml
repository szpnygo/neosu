<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NeoSuDoc</title><link>https://neosu.info/</link><description>Recent content on NeoSuDoc</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy; 2021 &lt;a href="https://neosu.info/">NeoSu&lt;/a></copyright><lastBuildDate>Mon, 24 May 2021 22:50:25 +0800</lastBuildDate><atom:link href="https://neosu.info/index.xml" rel="self" type="application/rss+xml"/><item><title>数组与切片</title><link>https://neosu.info/docs/server/golang_interview/array_and_slice.html</link><pubDate>Sat, 22 May 2021 11:07:53 +0800</pubDate><guid>https://neosu.info/docs/server/golang_interview/array_and_slice.html</guid><description/></item><item><title>Redis面试题</title><link>https://neosu.info/docs/server/redis_interview.html</link><pubDate>Mon, 24 May 2021 22:50:25 +0800</pubDate><guid>https://neosu.info/docs/server/redis_interview.html</guid><description>Redis的数据类型 string 字符串，常规的Key-Value缓存 hash field和value的映射表，适用于储存对象。 list 简单的字符串列表，按照插入顺序排序。消息</description></item><item><title>2.两数相加</title><link>https://neosu.info/docs/leetcode/linked_list/l2_add_two_number.html</link><pubDate>Fri, 14 May 2021 16:05:46 +0800</pubDate><guid>https://neosu.info/docs/leetcode/linked_list/l2_add_two_number.html</guid><description>题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个</description></item><item><title>45.跳跃游戏 II</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l45_jump_game_2.html</link><pubDate>Fri, 14 May 2021 19:13:57 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l45_jump_game_2.html</guid><description>题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个</description></item><item><title>45.跳跃游戏 II</title><link>https://neosu.info/docs/leetcode/greedy/l45_jump_game_2.html</link><pubDate>Fri, 14 May 2021 19:13:57 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l45_jump_game_2.html</guid><description>题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个</description></item><item><title>3.重复字符的最长子串</title><link>https://neosu.info/docs/leetcode/string/l3_longest_substring_without_repeating_characters.html</link><pubDate>Wed, 19 May 2021 13:43:21 +0800</pubDate><guid>https://neosu.info/docs/leetcode/string/l3_longest_substring_without_repeating_characters.html</guid><description>题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1： 输入: s = &amp;quot;abcabcbb&amp;quot; 输出: 3 解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quo</description></item><item><title>1.两数之和</title><link>https://neosu.info/docs/leetcode/array/l1_two_sum.html</link><pubDate>Fri, 14 May 2021 13:43:21 +0800</pubDate><guid>https://neosu.info/docs/leetcode/array/l1_two_sum.html</guid><description>题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案</description></item><item><title>53.最大子序和</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l53_maximum_subarray.html</link><pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l53_maximum_subarray.html</guid><description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的</description></item><item><title>55.跳跃游戏</title><link>https://neosu.info/docs/leetcode/greedy/l55_jump_game.html</link><pubDate>Fri, 14 May 2021 19:13:57 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l55_jump_game.html</guid><description>题目 给定一个非负整数数组$nums$ ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示</description></item><item><title>70.爬楼梯</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l70_climbing_stairs.html</link><pubDate>Sat, 08 May 2021 16:53:41 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l70_climbing_stairs.html</guid><description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例1： 输入：2</description></item><item><title>121.买卖股票的最佳时机</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l121_best_time_to_buy_and_sell_stock.html</link><pubDate>Sun, 09 May 2021 13:03:48 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l121_best_time_to_buy_and_sell_stock.html</guid><description>题目 给定一个数组 $prices$ ，它的第 $i$ 个元素 $prices[i]$ 表示一支给定股票第 $i$ 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法</description></item><item><title>122.买卖股票的最佳时机 II</title><link>https://neosu.info/docs/leetcode/greedy/l122_best_time_to_buy_and_sell_stock_2.html</link><pubDate>Tue, 18 May 2021 16:54:48 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l122_best_time_to_buy_and_sell_stock_2.html</guid><description>题目 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：</description></item><item><title>152.乘积最大子数组</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l152_maximum_product_subarray.html</link><pubDate>Wed, 12 May 2021 10:04:25 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l152_maximum_product_subarray.html</guid><description>题目 给你一个整数数组$nums$ ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例1： 输入: [2,3,-2,4] 输出:</description></item><item><title>198.打家劫舍</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l198_house_robber.html</link><pubDate>Wed, 12 May 2021 11:42:37 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l198_house_robber.html</guid><description>题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋</description></item><item><title>217.存在重复元素</title><link>https://neosu.info/docs/leetcode/array/l217_contains_duplicate.html</link><pubDate>Sun, 23 May 2021 21:58:12 +0800</pubDate><guid>https://neosu.info/docs/leetcode/array/l217_contains_duplicate.html</guid><description>题目 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例1： 输入: [1,2,3,1] 输出:</description></item><item><title>219.存在重复元素 II</title><link>https://neosu.info/docs/leetcode/array/l219_contains_duplicate_2.html</link><pubDate>Sun, 23 May 2021 21:58:12 +0800</pubDate><guid>https://neosu.info/docs/leetcode/array/l219_contains_duplicate_2.html</guid><description>题目 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 示例1： 输入: nums = [1,2,3,1], k =</description></item><item><title>220.存在重复元素 III</title><link>https://neosu.info/docs/leetcode/array/l220_contains_duplicate_3.html</link><pubDate>Sun, 23 May 2021 21:58:12 +0800</pubDate><guid>https://neosu.info/docs/leetcode/array/l220_contains_duplicate_3.html</guid><description>题目 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &amp;lt;= t ，同时又满足 abs(i - j) &amp;lt;= k 。 如果存在则返回 true，不存在返回 f</description></item><item><title>300.最长递增子序列</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l300_longest_increasing_subsequence.html</link><pubDate>Mon, 10 May 2021 08:35:34 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l300_longest_increasing_subsequence.html</guid><description>题目 给你一个整数数组$nums$ ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</description></item><item><title>322.零钱兑换</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l322_coin_change.html</link><pubDate>Thu, 13 May 2021 17:21:50 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l322_coin_change.html</guid><description>题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1</description></item><item><title>455.分发饼干</title><link>https://neosu.info/docs/leetcode/greedy/l455_assign_cookies.html</link><pubDate>Wed, 19 May 2021 14:51:33 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l455_assign_cookies.html</guid><description>题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口</description></item><item><title>673.最长递增子序列的个数</title><link>https://neosu.info/docs/leetcode/dynamic_programming/l673_number_of_longest_increasing+subsequence.html</link><pubDate>Mon, 10 May 2021 09:46:11 +0800</pubDate><guid>https://neosu.info/docs/leetcode/dynamic_programming/l673_number_of_longest_increasing+subsequence.html</guid><description>题目 给定一个未排序的整数数组，找到最长递增子序列的个数。 示例1： 输入: [1,3,5,4,7] 输出: 2 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。 示例2： 输</description></item><item><title>714.买卖股票的最佳时机含手续费</title><link>https://neosu.info/docs/leetcode/greedy/l714_best_time_to_buy_and_sell_stock_with_transaction_fee.html</link><pubDate>Thu, 20 May 2021 16:37:55 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l714_best_time_to_buy_and_sell_stock_with_transaction_fee.html</guid><description>题目 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需</description></item><item><title>860.柠檬水找零</title><link>https://neosu.info/docs/leetcode/greedy/l860_lemonade_change.html</link><pubDate>Tue, 18 May 2021 17:19:54 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l860_lemonade_change.html</guid><description>题目 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10</description></item><item><title>881.救生艇</title><link>https://neosu.info/docs/leetcode/greedy/l881_boats_to_save_people.html</link><pubDate>Fri, 21 May 2021 15:06:47 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l881_boats_to_save_people.html</guid><description>题目 第 $i$ 个人的体重为 $people[i]$，每艘船可以承载的最大重量为 $limit$。 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 $limi</description></item><item><title>1046.最后一块石头的重量</title><link>https://neosu.info/docs/leetcode/array/l1046_last_stone_weight.html</link><pubDate>Thu, 20 May 2021 16:00:11 +0800</pubDate><guid>https://neosu.info/docs/leetcode/array/l1046_last_stone_weight.html</guid><description>题目 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结</description></item><item><title>1217.玩筹码</title><link>https://neosu.info/docs/leetcode/greedy/l1217_minimum_cost_to_move_chips_to_the_same_position.html</link><pubDate>Thu, 20 May 2021 15:14:06 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l1217_minimum_cost_to_move_chips_to_the_same_position.html</guid><description>题目 数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。 你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2</description></item><item><title>1518.换酒问题</title><link>https://neosu.info/docs/leetcode/greedy/l1518_water_bottles.html</link><pubDate>Thu, 20 May 2021 15:42:43 +0800</pubDate><guid>https://neosu.info/docs/leetcode/greedy/l1518_water_bottles.html</guid><description>题目 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。 请你计算 最多 能喝到多少瓶酒。 示例1：</description></item><item><title>MySQL事务学习</title><link>https://neosu.info/posts/mysql_transaction.html</link><pubDate>Mon, 24 May 2021 22:35:46 +0800</pubDate><guid>https://neosu.info/posts/mysql_transaction.html</guid><description>MySQL事务学习 四大特性 数据库事务具备四大特性：原子性、一致性、隔离性、持久性。 原子性。一个事务中所有的操作，要么全部完成，那么全部不完成，不会结束</description></item><item><title>《认知觉醒：开启自我改变的原动力》读书笔记</title><link>https://neosu.info/posts/reading_cognitive_awakening.html</link><pubDate>Fri, 21 May 2021 09:36:56 +0800</pubDate><guid>https://neosu.info/posts/reading_cognitive_awakening.html</guid><description>懂得百点不如改变一点。真正的成长不在于自己懂得了多少道理，而在于自己改变了多少。 这本书讲了很多道理，也学到了很多，但是学习最重要的不是表层的学习，而且</description></item><item><title>Golang实现简单BitSet(二)</title><link>https://neosu.info/posts/golang-bitmap2.html</link><pubDate>Wed, 12 May 2021 15:16:29 +0800</pubDate><guid>https://neosu.info/posts/golang-bitmap2.html</guid><description>上一节中，我们实现了一个基本的BitSet，现在有个需求，计算BitSet中1的个数。 这个需求使用场景很多，比如统计在线用户数量等。之前的实现完成了记</description></item><item><title>Golang实现简单BitSet(一)</title><link>https://neosu.info/posts/golang-bitmap.html</link><pubDate>Mon, 10 May 2021 15:16:29 +0800</pubDate><guid>https://neosu.info/posts/golang-bitmap.html</guid><description>Bitmap (位图)是一个十分有用的数据结构。所谓的 Bit-map 就是用一个 bit 位来标记某个元素对应的 Value，而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，因此在内存占用</description></item><item><title>Redis Bitmap位图介绍与操作</title><link>https://neosu.info/posts/redis-bitmap.html</link><pubDate>Sat, 08 May 2021 09:50:30 +0800</pubDate><guid>https://neosu.info/posts/redis-bitmap.html</guid><description>位图介绍 Redis的位图(bitmap)是由多个二进制位组成的数组，数组中的每个二进制位都有与之对应的偏移量，用户通过这些偏移量可以对位图中指定一个或</description></item></channel></rss>